#L0=diag(apply(W0,1,sum))-W0
#####################################################################
errorK=c()
errorL=c()
Ratio=c()
XB=c()
Cors=c()
nLoop=0
for(k in 1:1000){
nLoop=nLoop+1
print(nLoop)
#This is the dense set-up
#New B2 definition this only works for p=q!!!
#New B2 definition this only works for p=q!!!
# B2=matrix(0,q,p)
# for (i in 1:(p/2)){
#   B2[1:(q/2),i]=runif(q/2,h1,h2)
# }
#
# for (i in (p/2+1):p){
#   B2[(q/2+1):q,i]=runif(q/2,h1,h2)
# }
#This is the sparse set-up
#New B2 definition this only works for p=q!!!
#New B2 definition this only works for p=q!!!
B2=matrix(0,q,p)
for (i in 1:(p/2)){
B2[1:(q/2),i]=runif(q/2,h2/2,h2)*rbinom(q/2,1,0.25)
}
for (i in (p/2+1):p){
B2[(q/2+1):q,i]=runif(q/2,h2/2,h2)*rbinom(q/2,1,0.25)
}
# for (i in 1:p){
#   B2[,i]=B2[,i]/sum(B2[,i]^2)^0.5
# }
# B2[is.na(B2)]=0
X=matrix(rnorm(n*q),n,q)
X=scale(X)#should I keep this?
Z=X%*%B2
#Set up the diagonal of epsilon.
S2=matrix(0,p,p)#cov30
#S2=S2+diag(p)
for (i in 1:(p/2-1)){
for(j in (i+1):(p/2)){
S2[i,j]=gamma-t(B2[,i])%*%B2[,j]
S2[j,i]=S2[i,j]
}
}
for (i in (p/2+1):(p-1)){
for(j in (i+1):p){
S2[i,j]=gamma-t(B2[,i])%*%B2[,j]
S2[j,i]=S2[i,j]
}
}
for (i in 1:p){
S2[i,i]=5-sum(B2[,i]^2)#This part is strange.
}
S2=nearPD(S2)
S2=S2$mat
e=mvrnorm(n, rep(0,p), S2)
Y=Z+e#cov00, s6
Cors[k]=mean(cor(Y[,1:(p/2)])-diag(p/2))
print(paste('mean of Cors is ',mean(Cors)))
#XB[k]=norm(X%*%B2,'F')^2
#Ratio[k]=XB[k]/norm(e,'F')^2
# T1=Z%*%B1
# T2=X%*%B2
# signal=c()
# for (i in 1:p){
#   signal[i]=var(T2[,i])^0.5/var(Y[,i])^0.5
# }
#
# plot(signal)
# X=matrix(rnorm(n*q),n,q)
# Y=matrix(rnorm(n*p),n,p)
# Z1=rnorm(n)
# Z2=rnorm(n)
#
# for (i in 1:(q/2)){
#   X[,i]=Z1+rnorm(n,0,1)
#   X[,i+q/2]=Z2+rnorm(n,0,1)
# }
# for (i in 1:(p/2)){
#   Y[,i]=Z1+rnorm(n,0,3)
#   Y[,i+p/2]=Z2+rnorm(n,0,3)
# }
# #
Res=NCutY2R1(Y,X,B,L,alpha=0.75,ncv=5)
Cx=Res[[2]]
f11=matrix(Cx[,1],p,1)
f12=matrix(Cx[,2],p,1)
errorL[k]=sum((f11%*%t(f11))*W0)/Denum+sum((f12%*%t(f12))*W0)/Denum
k1=kmeans(t(scale(Y)), 2, nstart = 1)
f21=matrix(k1$cluster-1,p,1)
f22=matrix(abs(k1$cluster-2),p,1)
errorK[k]=sum((f21%*%t(f21))*W0)/Denum+sum((f22%*%t(f22))*W0)/Denum
print(paste('The errorL is',mean(errorL,na.rm=TRUE)))
print(paste('The errorK is',mean(errorK,na.rm=TRUE)))
print(paste('Relative improvement ',1-mean(errorL,na.rm=TRUE)/mean(errorK,na.rm=TRUE)))
print(paste('Proportion of time better', length(which(errorK>=errorL))/length(errorK)))
print(apply(B2^2,2,sum))
}
#errorL=0.326
#errorK=0.167
####################
# plot(X[,2],Y[,2])
# cor(X[,1],Y[,1])
# mean(errorL)
# mean(errorK)
# plot(errorK,errorL)
# abline(0,1)
# 1-length(which(errorK<errorL))/length(errorK)
# #stopCluster(cl)
# min(Res[[1]])
# table(errorK)
# plot(Res[[1]],type='l')
# #MTA eTIX
# table(f11[1:(p/2)])
# table(f11[(p/2+1):p])
# table(f21[1:(p/2)])
# table(f21[(p/2+1):p])
n=30
B=3000
L=1000
p=40
q=p/2
#set.seed(666)
h1=0
h2=0.75
gamma=0.75##/10
W0=matrix(1,p,p)
W0[1:(p/2),1:(p/2)]=0
W0[(p/2+1):p,(p/2+1):p]=0
Denum=sum(W0)
#L0=diag(apply(W0,1,sum))-W0
#####################################################################
errorK=c()
errorL=c()
Ratio=c()
XB=c()
Cors=c()
nLoop=0
for(k in 1:1000){
nLoop=nLoop+1
print(nLoop)
#This is the dense set-up
#New B2 definition this only works for p=q!!!
#New B2 definition this only works for p=q!!!
# B2=matrix(0,q,p)
# for (i in 1:(p/2)){
#   B2[1:(q/2),i]=runif(q/2,h1,h2)
# }
#
# for (i in (p/2+1):p){
#   B2[(q/2+1):q,i]=runif(q/2,h1,h2)
# }
#This is the sparse set-up
#New B2 definition this only works for p=q!!!
#New B2 definition this only works for p=q!!!
B2=matrix(0,q,p)
for (i in 1:(p/2)){
B2[1:(q/2),i]=runif(q/2,h2/2,h2)*rbinom(q/2,1,0.25)
}
for (i in (p/2+1):p){
B2[(q/2+1):q,i]=runif(q/2,h2/2,h2)*rbinom(q/2,1,0.25)
}
# for (i in 1:p){
#   B2[,i]=B2[,i]/sum(B2[,i]^2)^0.5
# }
# B2[is.na(B2)]=0
X=matrix(rnorm(n*q),n,q)
X=scale(X)#should I keep this?
Z=X%*%B2
#Set up the diagonal of epsilon.
S2=matrix(0,p,p)#cov30
#S2=S2+diag(p)
for (i in 1:(p/2-1)){
for(j in (i+1):(p/2)){
S2[i,j]=gamma-t(B2[,i])%*%B2[,j]
S2[j,i]=S2[i,j]
}
}
for (i in (p/2+1):(p-1)){
for(j in (i+1):p){
S2[i,j]=gamma-t(B2[,i])%*%B2[,j]
S2[j,i]=S2[i,j]
}
}
for (i in 1:p){
S2[i,i]=5-sum(B2[,i]^2)#This part is strange.
}
S2=nearPD(S2)
S2=S2$mat
e=mvrnorm(n, rep(0,p), S2)
Y=Z+e#cov00, s6
Cors[k]=mean(cor(Y[,1:(p/2)])-diag(p/2))
print(paste('mean of Cors is ',mean(Cors)))
#XB[k]=norm(X%*%B2,'F')^2
#Ratio[k]=XB[k]/norm(e,'F')^2
# T1=Z%*%B1
# T2=X%*%B2
# signal=c()
# for (i in 1:p){
#   signal[i]=var(T2[,i])^0.5/var(Y[,i])^0.5
# }
#
# plot(signal)
# X=matrix(rnorm(n*q),n,q)
# Y=matrix(rnorm(n*p),n,p)
# Z1=rnorm(n)
# Z2=rnorm(n)
#
# for (i in 1:(q/2)){
#   X[,i]=Z1+rnorm(n,0,1)
#   X[,i+q/2]=Z2+rnorm(n,0,1)
# }
# for (i in 1:(p/2)){
#   Y[,i]=Z1+rnorm(n,0,3)
#   Y[,i+p/2]=Z2+rnorm(n,0,3)
# }
# #
Res=NCutY2R1(Y,X,B,L,alpha=0,ncv=5)
Cx=Res[[2]]
f11=matrix(Cx[,1],p,1)
f12=matrix(Cx[,2],p,1)
errorL[k]=sum((f11%*%t(f11))*W0)/Denum+sum((f12%*%t(f12))*W0)/Denum
k1=kmeans(t(scale(Y)), 2, nstart = 1)
f21=matrix(k1$cluster-1,p,1)
f22=matrix(abs(k1$cluster-2),p,1)
errorK[k]=sum((f21%*%t(f21))*W0)/Denum+sum((f22%*%t(f22))*W0)/Denum
print(paste('The errorL is',mean(errorL,na.rm=TRUE)))
print(paste('The errorK is',mean(errorK,na.rm=TRUE)))
print(paste('Relative improvement ',1-mean(errorL,na.rm=TRUE)/mean(errorK,na.rm=TRUE)))
print(paste('Proportion of time better', length(which(errorK>=errorL))/length(errorK)))
print(apply(B2^2,2,sum))
}
n=30
B=3000
L=1000
p=40
q=p/2
#set.seed(666)
h1=0
h2=0.75
gamma=0.75##/10
W0=matrix(1,p,p)
W0[1:(p/2),1:(p/2)]=0
W0[(p/2+1):p,(p/2+1):p]=0
Denum=sum(W0)
#L0=diag(apply(W0,1,sum))-W0
#####################################################################
errorK=c()
errorL=c()
Ratio=c()
XB=c()
Cors=c()
nLoop=0
for(k in 1:1000){
nLoop=nLoop+1
print(nLoop)
#This is the dense set-up
#New B2 definition this only works for p=q!!!
#New B2 definition this only works for p=q!!!
# B2=matrix(0,q,p)
# for (i in 1:(p/2)){
#   B2[1:(q/2),i]=runif(q/2,h1,h2)
# }
#
# for (i in (p/2+1):p){
#   B2[(q/2+1):q,i]=runif(q/2,h1,h2)
# }
#This is the sparse set-up
#New B2 definition this only works for p=q!!!
#New B2 definition this only works for p=q!!!
B2=matrix(0,q,p)
for (i in 1:(p/2)){
B2[1:(q/2),i]=runif(q/2,h2/2,h2)*rbinom(q/2,1,0.25)
}
for (i in (p/2+1):p){
B2[(q/2+1):q,i]=runif(q/2,h2/2,h2)*rbinom(q/2,1,0.25)
}
# for (i in 1:p){
#   B2[,i]=B2[,i]/sum(B2[,i]^2)^0.5
# }
# B2[is.na(B2)]=0
X=matrix(rnorm(n*q),n,q)
X=scale(X)#should I keep this?
Z=X%*%B2
#Set up the diagonal of epsilon.
S2=matrix(0,p,p)#cov30
#S2=S2+diag(p)
for (i in 1:(p/2-1)){
for(j in (i+1):(p/2)){
S2[i,j]=gamma-t(B2[,i])%*%B2[,j]
S2[j,i]=S2[i,j]
}
}
for (i in (p/2+1):(p-1)){
for(j in (i+1):p){
S2[i,j]=gamma-t(B2[,i])%*%B2[,j]
S2[j,i]=S2[i,j]
}
}
for (i in 1:p){
S2[i,i]=5-sum(B2[,i]^2)#This part is strange.
}
S2=nearPD(S2)
S2=S2$mat
e=mvrnorm(n, rep(0,p), S2)
Y=Z+e#cov00, s6
Cors[k]=mean(cor(Y[,1:(p/2)])-diag(p/2))
print(paste('mean of Cors is ',mean(Cors)))
#XB[k]=norm(X%*%B2,'F')^2
#Ratio[k]=XB[k]/norm(e,'F')^2
# T1=Z%*%B1
# T2=X%*%B2
# signal=c()
# for (i in 1:p){
#   signal[i]=var(T2[,i])^0.5/var(Y[,i])^0.5
# }
#
# plot(signal)
# X=matrix(rnorm(n*q),n,q)
# Y=matrix(rnorm(n*p),n,p)
# Z1=rnorm(n)
# Z2=rnorm(n)
#
# for (i in 1:(q/2)){
#   X[,i]=Z1+rnorm(n,0,1)
#   X[,i+q/2]=Z2+rnorm(n,0,1)
# }
# for (i in 1:(p/2)){
#   Y[,i]=Z1+rnorm(n,0,3)
#   Y[,i+p/2]=Z2+rnorm(n,0,3)
# }
# #
Res=NCutY2R1(Y,X,B,L,alpha=0.25,ncv=5)
Cx=Res[[2]]
f11=matrix(Cx[,1],p,1)
f12=matrix(Cx[,2],p,1)
errorL[k]=sum((f11%*%t(f11))*W0)/Denum+sum((f12%*%t(f12))*W0)/Denum
k1=kmeans(t(scale(Y)), 2, nstart = 1)
f21=matrix(k1$cluster-1,p,1)
f22=matrix(abs(k1$cluster-2),p,1)
errorK[k]=sum((f21%*%t(f21))*W0)/Denum+sum((f22%*%t(f22))*W0)/Denum
print(paste('The errorL is',mean(errorL,na.rm=TRUE)))
print(paste('The errorK is',mean(errorK,na.rm=TRUE)))
print(paste('Relative improvement ',1-mean(errorL,na.rm=TRUE)/mean(errorK,na.rm=TRUE)))
print(paste('Proportion of time better', length(which(errorK>=errorL))/length(errorK)))
print(apply(B2^2,2,sum))
}
using namespace Rcpp;
library(NCutYX)
?NCutY2R1
library(NCutYX)
library(NCutYX)
?NCutYR1
library(NCutYX)
?NCutYR1
library(NCutYX)
?NCutYR1
library(NCutYX)
?NCutYR1
library(NCutYX)
library(NCutYX)
library(NCutYX)
library(NCutYX)
library(NCutYX)
library(NCutYX)
library(NCutYX)
library(NCutYX)
?NCutY3V1
??NCutY3V1
NCutY3V1
library(NCutYX)
max(c(1,2,Inf))
1/30
1/1
1/0.1
exp(-0.1)
library(NCutYX)
library(NCutYX)
library(NCutYX)
library(NCutYX)
library(NCutYX)
library(NCutYX)
?NCutYX
??NCutYX
?NCutYLayer3R1
library(NCutYX)
library(NCutYX)
library(NCutYX)
library(NCutYX)
library(NCutYX)
library(NCutYX)
library(NCutYX)
library(NCutYX)
library(NCutYX)
library(NCutYX)
library(NCutYX)
library(NCutYX)
library(NCutYX)
library(NCutYX)
library(NCutYX)
library(NCutYX)
library(NCutYX)
library(NCutYX)
library(NCutYX)
library(NCutYX)
library(NCutYX)
library(NCutYX)
library(NCutYX)
library(NCutYX)
library(NCutYX)
library(NCutYX)
library(NCutYX)
q=10
p=10
r=10
K=3
Cx=matrix(0,q+p+r,K)
#Below: force the result to have one member per type of data and cluster.
#You should use a While loop? Sum the cluster membership by data type.
for (i in 1:(q+p+r)){
Cx[i,sample(K,1)]=1
}
Cx
Check=matrix(0,3,K)
Check[1,]=apply(Cx[1:q,1:K],2,sum)
Check[2,]=apply(Cx[(q+1):(q+p),1:K],2,sum)
Check[3,]=apply(Cx[(p+q+1):(q+p+r),1:K],2,sum)
Check
q=20
p=20
r=20
for (i in 1:(q+p+r)){
Cx[i,sample(K,1)]=1
}
Check[1,]=apply(Cx[1:q,1:K],2,sum)
Check[2,]=apply(Cx[(q+1):(q+p),1:K],2,sum)
Check[3,]=apply(Cx[(p+q+1):(q+p+r),1:K],2,sum)
Check=matrix(0,3,K)
for (i in 1:(q+p+r)){
Cx[i,sample(K,1)]=1
}
Check[1,]=apply(Cx[1:q,1:K],2,sum)
Check[2,]=apply(Cx[(q+1):(q+p),1:K],2,sum)
Check[3,]=apply(Cx[(p+q+1):(q+p+r),1:K],2,sum)
Cx=matrix(0,q+p+r,K)
for (i in 1:(q+p+r)){
Cx[i,sample(K,1)]=1
}
Check[1,]=apply(Cx[1:q,1:K],2,sum)
Check[2,]=apply(Cx[(q+1):(q+p),1:K],2,sum)
Check[3,]=apply(Cx[(p+q+1):(q+p+r),1:K],2,sum)
Check
Which(Check<=2)
which(Check<=2)
(Check<=2)
sum((Check<=2))
Cx=matrix(0,q+p+r,K)
#Below: force the result to have one member per type of data and cluster.
#You should use a While loop? Sum the cluster membership by data type.
Check=matrix(0,3,K)
while(sum((Check<=2))>0){
for (i in 1:(q+p+r)){
Cx[i,sample(K,1)]=1
}
Check[1,]=apply(Cx[1:q,1:K],2,sum)
Check[2,]=apply(Cx[(q+1):(q+p),1:K],2,sum)
Check[3,]=apply(Cx[(p+q+1):(q+p+r),1:K],2,sum)
}
Check
Cx
Min=2
Check=matrix(0,3,K)
while(sum((Check<=Min))>0){
for (i in 1:(q+p+r)){
Cx[i,sample(K,1)]=1
}
Check[1,]=apply(Cx[1:q,1:K],2,sum)
Check[2,]=apply(Cx[(q+1):(q+p),1:K],2,sum)
Check[3,]=apply(Cx[(p+q+1):(q+p+r),1:K],2,sum)
}
Check
p=20
q=20
r=20
K=3
Cx=matrix(0,q+p+r,K)
Min=2
Check=matrix(0,3,K)
while(sum((Check<=Min))>0){
for (i in 1:(q+p+r)){
Cx[i,sample(K,1)]=1
}
Check[1,]=apply(Cx[1:q,1:K],2,sum)
Check[2,]=apply(Cx[(q+1):(q+p),1:K],2,sum)
Check[3,]=apply(Cx[(p+q+1):(q+p+r),1:K],2,sum)
}
Nx=Check
C2x=matrix(0,p,K)
C2x=Cx
?sample.int
library(NCutYX)
ZYX=cbind(Z,Y,X)
library(NCutYX)
library(NCutYX)
library(NCutYX)
library(NCutYX)
library(NCutYX)
library(NCutYX)
