% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/NCutYX.R
\name{sncut}
\alias{sncut}
\title{Cluster the columns of Y into K groups using the NCut graph measure.}
\usage{
sncut(X, Z, K, lambda, B = 500, L = 1000)
}
\arguments{
\item{K}{is the number of clusters.}

\item{B}{is the number of iterations.}

\item{Y}{is a n x p matrix of p variables and n observations. The p columns of
Y will be clustered into K groups using NCut.}

\item{N}{is the number of samples per iterations.}

\item{scale}{equals TRUE if data Y is to be scaled with mean 0 and variance 1.}
}
\value{
A list with the final value of the objective function and
the clusters.
}
\description{
This function will output K clusters of the columns of Y.
}
\details{
The algorithm minimizes the NCut through the cross entropy method.
The clusters correspond to partitions that minimize this objective function.
}
\examples{
#This sets up the initial parameters for the simulation.
library(NCutYX)
library(MASS)
library(fields) #for image.plot
#parameters#
n=150
p=50
h=0.25
rho=0.4

W0=matrix(1,p,p)
W0[1:(p/5),1:(p/5)]=0
W0[(p/5+1):(3*p/5),(p/5+1):(3*p/5)]=0
W0[(3*p/5+1):(4*p/5),(3*p/5+1):(4*p/5)]=0
W0[(4*p/5+1):p,(4*p/5+1):p]=0
W0=cbind(W0,W0,W0)
W0=rbind(W0,W0,W0)

Y=matrix(0,n,p)
Z=matrix(0,n,p)
Sigma=matrix(0,p,p)
Sigma[1:(p/5),1:(p/5)]=rho
Sigma[(p/5+1):(3*p/5),(p/5+1):(3*p/5)]=rho
Sigma[(3*p/5+1):(4*p/5),(3*p/5+1):(4*p/5)]=rho
Sigma[(4*p/5+1):p,(4*p/5+1):p]=rho
Sigma=Sigma-diag(diag(Sigma))
Sigma=Sigma+diag(p)

X=mvrnorm(n,rep(0,p),Sigma)
B1=matrix(0,p,p)
B2=matrix(0,p,p)

B1[1:(p/5),1:(p/5)]=runif((p/5)^2,h/2,h)*rbinom((p/5)^2,1,0.5)
B1[(p/5+1):(3*p/5),(p/5+1):(3*p/5)]=runif((2*p/5)^2,h/2,h)*rbinom((2*p/5)^2,1,0.5)
B1[(3*p/5+1):(4*p/5),(3*p/5+1):(4*p/5)]=runif((p/5)^2,h/2,h)*rbinom((p/5)^2,1,0.5)
B1[(4*p/5+1):p,(4*p/5+1):p]=runif((1*p/5)^2,h/2,h)*rbinom((1*p/5)^2,1,0.5)

B2[1:(p/5),1:(p/5)]=runif((p/5)^2,h/2,h)*rbinom((p/5)^2,1,0.5)
B2[(p/5+1):(3*p/5),(p/5+1):(3*p/5)]=runif((2*p/5)^2,h/2,h)*rbinom((2*p/5)^2,1,0.5)
B2[(3*p/5+1):(4*p/5),(3*p/5+1):(4*p/5)]=runif((p/5)^2,h/2,h)*rbinom((p/5)^2,1,0.5)
B2[(4*p/5+1):p,(4*p/5+1):p]=runif((1*p/5)^2,h/2,h)*rbinom((1*p/5)^2,1,0.5)

B2[1:(p/5),1:(p/5)]=runif((p/5)^2,h/2,h)*rbinom((p/5)^2,1,0.5)
B2[(p/5+1):(3*p/5),(p/5+1):(3*p/5)]=runif((2*p/5)^2,h/2,h)*rbinom((2*p/5)^2,1,0.5)
B2[(3*p/5+1):(4*p/5),(3*p/5+1):(4*p/5)]=runif((p/5)^2,h/2,h)*rbinom((p/5)^2,1,0.5)
B2[(4*p/5+1):p,(4*p/5+1):p]=runif((1*p/5)^2,h/2,h)*rbinom((1*p/5)^2,1,0.5)

Y=X\%*\%B1+matrix(rnorm(n*p,0,0.25),n,p)

Z=Y\%*\%B2+matrix(rnorm(n*p,0,0.25),n,p)

#Computing our method
clust<-bml(Z,
           Y,
           X,
           K=4,
           R=1,
           B=50,
           N=1000,
           dist='correlation',
           scale=F,
           eta=0.25)
plot(clust[[1]],type='l')
image.plot(clust[[3]])
}
