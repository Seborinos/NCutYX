% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/NCutYX.R
\name{ANCut}
\alias{ANCut}
\title{Cluster the columns of Y into K groups with the help of external features in X.}
\usage{
ANCut(Y, X, K = 2, B = 3000, L = 1000, alpha = 0.5, nlambdas = 100,
  ncv = 5, dist = "gaussian", sigma = 1)
}
\arguments{
\item{Y}{is a n x p matrix of p variables and n observations. The columns of
Y will be clustered into K groups.}

\item{X}{is a n x q matrix of q variables and n observations.}

\item{B}{is the number of iterations in the simulated annealing algorithm.}

\item{L}{is the temperature coefficient in the simulated annealing algorithm.}

\item{alpha}{is the coefficient of the elastic net penalty.}

\item{nlambdas}{is the number of tunning parameters in the elastic net.}

\item{ncv}{is the number of cross-validations in the elastic net.}
}
\value{
A list with the final value of the objective function,
the clusters and the lambda penalty chosen through cross-validation.
}
\description{
This function will output K clusters of  the columns of Y, using the help of
X.
}
\details{
The algorithm minimizes a modified version of NCut through simulated annealing.
The clusters correspond to partitions that minimize this objective function.
The external information of X is incorporated by using ridge regression to predict Y.
}
\examples{
#This sets up the initial parameters for the simulation.
n=200 #Sample size
B=5000 #Number of iterations in the simulated annealing algorithm.
L=1000 #Temperature coefficient.
p=500 #Number of columns of Y.
q=p #Number of columns of X.
h1=0
h2=0.15

S=matrix(0.2,q,q)
S[1:(q/2),(q/2+1):q]=0
S[(q/2+1):q,1:(q/2)]=0
S=S-diag(diag(S))+diag(q)
S=nearPD(S)
S=S$mat
mu=rep(0,q)

W0=matrix(1,p,p)
W0[1:(p/2),1:(p/2)]=0
W0[(p/2+1):p,(p/2+1):p]=0
Denum=sum(W0)

B2=matrix(0,q,p)
for (i in 1:(p/2)){
   B2[1:(q/2),i]=runif(q/2,h1,h2)
   in1=sample.int(q/2,6)
   B2[-in1,i]=0
}

for (i in (p/2+1):p){
   B2[(q/2+1):q,i]=runif(q/2,h1,h2)
   in2=sample(seq(q/2+1,q),6)
   B2[-in2,i]=0
}

X=mvrnorm(n, mu, S)
Z=X\%*\%B2
Y=Z+matrix(rnorm(n*p,0,2),n,p)
#Our method
Res=NCutY2R1(Y,X,B,L,alpha=0,ncv=5)
Cx=Res[[2]]
f11=matrix(Cx[,1],p,1)
f12=matrix(Cx[,2],p,1)

errorL=sum((f11\%*\%t(f11))*W0)/Denum+sum((f12\%*\%t(f12))*W0)/Denum
#This is the true error of the clustering solution.
errorL
}
